[dataset]
# Specify how many images should be rendered
image_count = 123
# Specify the base path where data will be written to. Note that this is a base
# path, to which additional information will be added such as Scenario-Number
# and Camera-Name
base_path = $AMIRA_DATASETS/WorkstationScenarios-Train
# specify a backend script for dataset generation
backend_script = $HOME/amira/amira_blender_rendering/scenes/basic_scene.py
# specify the scene type from the backend script
scene_type = BasicScene

[camera_info]
# In this section you specify the camera information, which will have a direct
# impact on rendering results.

# The width and height have an influence on the rendering resolution. In case
# you wish to set a specific calibration matrix that you obtained, for
# instance, from OpenCV, and do not wish to temper with the rendering
# resolution, then set these values to 0.
width = 640
height = 480

# The camera model to use. At the moment, this value is ignored in
# amira_blender_rendering. However, because all rendering is in fact done with a
# pinhole camera model, this value serves as documentation
model = pinhole

# Also this value has no impact on rendering likewise the model. However, if
# you want to specify a certain camera name for documentation purposes, this is
# the place.
name = Pinhole Camera

# blender uses OpenGL conventions. that is, it assumes that a camera looks into
# the negative Z direction. Modelling, however, is usually done such that the XY
# plane spans the "floor" of an environment. Hence, a camera looks from the top
# onto objects. In turn, all relative rotations are computed in this manner.
# Specifically, that means that a seemingly 'upright' standing object in front
# of the camera actually has a rotation of 90 degrees.
#
# If you wish to change this behavior, you can change the default "zeroing"
# rotation of a camera with the following flag. That is, a more natural
# understanding can be achieved when the 0 deg rotation looks at an object from
# the front - i.e., when the camera is looking along the Y axis. This can be
# achieved by rotating the camera by 90 degrees around X.
#
# The following configuration parameter allows to change this behavior. The
# default is 0, 0, 0 which means that the camera is not rotated and relative
# rotations are computed as by convention in OpenGL, and therefore blender.
zeroing = 0, 0, 0

# You can specify the intrinsic calibration information that was determined for
# a camera, for instance with OpenCV.
#
# Here, we use the format
#   intrinsics = fx, fy, cx, cy
# Where the fx, fy values represented focal lengths, and cx, cy defines the
# camera's principal point.
#
# You can extract fx, fy, cx, cy from a calibration matrix K:
#
#         fx  s   cx
#    K =   0  fy  cy
#          0  0   1
#
# Note, however, that the values in your calibration matrix or intrinsics
# specification might not end up in proper render resolutions. For instance,
# this is the case in the example below, which would result in a rendering
# resolution of about 1320.98 x 728.08.  Blender will round these values to
# suitable integer values.  As a consequence, even if you set width and height
# above to 0, the effective intrinsics that blender uses might be slightly
# different from your K.
#
# To accomodate this 'issue', amira_blender_rendering will write a value
# 'effective_intrinsics' to the configuration as soon as setting up cameras and
# rendering is done. Recall that all configurations will be stored alongside the
# created dataset, so you can easily retrieve the effective_intrinsics in
# downstream applications
use_intrinsics = True
intrinsics = 9.9801747708520452e+02,9.9264009290521165e+02,6.6049856967197002e+02,3.6404286361152555e+02,0

[camera_info.Camera.001]
use_intrinsics = True
intrinsics = 980, 900, 640, 480


[render_setup]
# specify which renderer to use. Usually you should leave this at
# blender-cycles. Note that, at the moment, this is hard-coded to cycles
# internally anyway.
backend = blender-cycles
# integrator (either PATH or BRANCHED_PATH)
integrator = BRANCHED_PATH
# use denoising (true, false)
denoising = True
# samples the ray-tracer uses per pixel
samples = 64
# render images with occluded objects
allow_occlusions = True


[scene_setup]
# specify the blender file from which to load the scene
# blend_file = $AMIRA_DATA_GFX/modeling/workstation_scenarios.blend
blend_file = $AMIRA_DATA_GFX/modeling/workstation_scenarios_thin.blend
# specify where background / environment images will be taken from during
# rendering. This can be a single file, or a directory containing images
environment_texture = $AMIRA_DATASETS/OpenImagesV4/Images
# specify which cameras to use for rendering. The names here follow the names in
# the blender file, i.e. Camera, StereoCamera.Left, StereoCamera.Right
cameras = Camera, Camera.001
# cameras = Camera, StereoCamera.Left, StereoCamera.Right
# number of frames to forward-simulate in the physics simulation
forward_frames = 15
# number of different frames to create by randomly dropping the objects
num_frames = 1
#number of camera locations in viewsphere
num_camera_locations = 2

[parts]
sterngriff.file_path = $AMIRA_DATA_GFX/cad/rexroth/sterngriff.blend
# special: if the name of the object in the blender file differs from the name
# you're using here, you can specify the name here.
#sterngriff.name = Sterngriff.001
sterngriff.scale = 0.001

# a cube-like connection
wuerfelverbinder_40x40.file_path = $AMIRA_DATA_GFX/cad/rexroth/wuerfelverbinder_40x40.blend
wuerfelverbinder_40x40.scale = 0.001

[scenario_setup]
# At the moment, the 6 different scenarios in workstation_scenarios.blend are
# simply enumerated. Have a look at the .blend file for the order in which they
# appear, e.g. identifiable by the numbering of the cameras
scenario = 1
# Specify all target objects that shall be dropped at random locations into the
# environment. Target objects are all those objects that are already in the
# .blend file in the 'Proto' collection. You can also specify parts that were
# presented above using the syntax 'parts.partname:count'
target_objects = Cube:5, parts.sterngriff:1, parts.wuerfelverbinder_40x40:7
# parts from ABC Industrial Object Dataset
num_abc_colors = 4
abc_objects = bearings:1, random:6
